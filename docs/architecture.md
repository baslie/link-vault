# Архитектура и реализация системы "Link Vault"

Документ описывает целевую архитектуру и ключевые технические решения проекта "Link Vault" на основе брифа из `docs/brief.md`. Основная цель — зафиксировать структуру системы, распределение ответственности между компонентами, формат данных и потоки взаимодействия, чтобы обеспечить согласованную реализацию и дальнейшее сопровождение.

## 1. Общий обзор

### 1.1 Цель продукта

"Link Vault" — личный (но поддерживающий несколько пользователей) сервис для сохранения, каталогизации и быстрого поиска интернет-ссылок. Система должна быть:

- **Простой** — без избыточных функций, минималистичный интерфейс.
- **Быстрой** — отзывчивый UI и мгновенный поиск.
- **Надежной** — данные не должны теряться, регулярные бекапы.
- **Масштабируемой** — стабильная работа при тысячах ссылок на пользователя.

### 1.2 Целевая аудитория и сценарии

- **Первичный пользователь** — автор проекта, использующий сервис как личный vault ссылок.
- **Вторичная аудитория** — узкий круг доверенных людей для тестирования.
- **Основные сценарии**: сохранение ссылок, структурирование по тегам, быстрый поиск, ведение рабочих и личных подборок, просмотр архива знаний, импорт/экспорт данных.

### 1.3 Высокоуровневая архитектура

```
┌──────────────┐       HTTPS        ┌───────────────────┐
│  Browser UI  │ <----------------> │  Next.js App (FE) │
└──────────────┘                    │  + API Routes     │
                                     └──────┬────────────┘
                                            │ Supabase client SDK
                                            ▼
                                     ┌───────────────────┐
                                     │   Supabase BaaS   │
                                     │  (PostgreSQL +    │
                                     │   Auth + Storage) │
                                     └───────────────────┘
```

- **Frontend**: Next.js 14 (App Router), React 18, TypeScript, Shadcn/ui, Tailwind CSS. Выполняет SSR/SSG и предоставляет API routes для вспомогательных операций (например, получения метаданных).
- **Backend**: Supabase (PostgreSQL + Supabase Auth + Storage). Логика доступа реализована через Row Level Security (RLS), SQL-функции и edge functions (при необходимости).
- **Интеграции**: Vercel (deployment), Supabase Storage (фавиконки), внешние аналитические сервисы (Яндекс.Метрика, Google Analytics).

## 2. Компонентная архитектура фронтенда

### 2.1 Структура проекта Next.js

- **App Router**: маршруты `/` (главная таблица ссылок), `/import`, `/export`, `/admin`, `/settings`, `/auth/*`.
- **Server Components**: загрузка данных, которые можно получить на сервере (например, список тегов или конфигурация пользователя) для оптимизации SEO и скорости.
- **Client Components**: интерактивные элементы (таблица, фильтры, формы добавления/редактирования).
- **API routes**: `/api/metadata` (получение title/favicons), `/api/import/preview`, `/api/import/commit`, `/api/export`.

### 2.2 UI-компоненты

- Используются компоненты из Shadcn/ui как база, расширяемые по необходимости.
- Ключевые блоки интерфейса:
  - **Header**: логотип, глобальный поиск, кнопка добавления, меню профиля.
  - **TagBar**: список тегов-пилюль с множественным выбором, кнопкой "Сбросить все" и индикатором выбранных тегов.
  - **LinksTable**: таблица с колонками FavIcon, Title, URL, Comment, Tags, Date, Actions. Поддерживает сортировку, пагинацию, inline-редактирование.
  - **LinkForm**: форма добавления/редактирования ссылок с автозаполнением title, выбором/созданием тегов и валидацией URL (Zod).
  - **SearchBar**: поле с подсветкой совпадений (highlighting) в результатах.
  - **ThemeToggle**: переключатель тем (light/dark) с использованием CSS variables в Tailwind.
  - **Responsive wrappers**: компоненты, обеспечивающие отображение списка в виде карточек на мобильных устройствах.

### 2.3 Управление состоянием и данные

- **React Query**:
  - Фетчинг данных ссылок (`useLinksQuery`) с учетом параметров фильтра/сортировки/пагинации.
  - Кэширование тегов (`useTagsQuery`), пользовательских настроек (`useUserSettingsQuery`).
  - Мутации: `useCreateLink`, `useUpdateLink`, `useDeleteLink`, `useImportLinks`, `useExportLinks`.
- **Сохранение фильтров**: query-параметры URL отражают текущий поиск, сортировку, выбранные теги и диапазон дат. Это позволяет делиться состоянием таблицы и сохранять историю.
- **Форма добавления**: контролируемые компоненты, валидация через Zod schema, мгновенная обратная связь об ошибках.

### 2.4 Поиск и фильтрация на клиенте

- Пользовательский ввод (поиск, теги, сортировки) отправляется как параметры запроса в React Query.
- Подсветка совпадений реализуется путем передачи поискового запроса в компонент таблицы, который выделяет match в Title/Comment/URL.
- Выбранные теги отображаются отдельными бейджами над таблицей; при множественном выборе используется логика `AND`.

### 2.5 Адаптивность и доступность

- **Desktop first**: основной макет — таблица на всю ширину с панелью тегов.
- **Tablet**: скрытие некоторых колонок (например, комментарий) при недостатке ширины; доступ к скрытым данным через раскрываемый блок внутри строки.
- **Mobile**: отображение списком карточек, каждая карточка включает основные поля, кнопки действий и collapsible для дополнительных данных.
- **Доступность**: использование semantic HTML, ARIA-атрибутов для интерактивных элементов, поддержка клавиатурной навигации (таблица должна позволять управление стрелками/Tab).

## 3. Архитектура Supabase (Backend)

### 3.1 Структура базы данных

#### Таблицы

- `profiles`
  - `id` (uuid, PK, соответствует `auth.users.id`)
  - `email` (text, уникальный)
  - `display_name` (text)
  - `theme` (enum: `light`|`dark`|`system`)
  - `created_at`, `updated_at`
- `links`
  - `id` (uuid, PK)
  - `user_id` (uuid, FK → `profiles.id`)
  - `url` (text, уникальный в паре с `user_id`)
  - `title` (text)
  - `comment` (text)
  - `created_at` (timestamp)
  - `updated_at` (timestamp)
  - `fav_icon_path` (text, nullable) — путь к объекту в Supabase Storage
  - `metadata_source` (jsonb) — кэш ответа сервиса метаданных
- `tags`
  - `id` (uuid, PK)
  - `user_id` (uuid, FK → `profiles.id`)
  - `name` (citext) — уникально в паре с `user_id`
  - `color` (text) — HEX или токен Tailwind
  - `created_at`, `updated_at`
- `link_tags`
  - `link_id` (uuid, FK → `links.id` ON DELETE CASCADE)
  - `tag_id` (uuid, FK → `tags.id` ON DELETE CASCADE)
  - Композитный PK (`link_id`, `tag_id`)
- `imports`
  - `id` (uuid, PK)
  - `user_id` (uuid)
  - `source` (text) — описание файла/происхождения
  - `status` (enum: `pending`, `completed`, `failed`)
  - `total_rows`, `imported_rows`, `duplicate_rows`, `failed_rows`
  - `created_at`
- `import_errors`
  - `id` (uuid, PK)
  - `import_id` (uuid, FK → `imports.id` ON DELETE CASCADE)
  - `row_number` (integer)
  - `url` (text)
  - `error_code` (text)
  - `error_details` (jsonb)
- `audit_link_events` (опционально для админской статистики)
  - `id` (uuid, PK)
  - `user_id`
  - `link_id`
  - `event_type` (`created`, `updated`, `deleted`, `imported`)
  - `event_timestamp`

#### Индексы и оптимизация

- Индекс по `links(user_id, created_at DESC)` для сортировки по дате.
- Индекс по `links(user_id, title)` для сортировки по названию.
- GIN-индекс по `to_tsvector('simple', title || ' ' || coalesce(comment,''))` для полнотекстового поиска.
- Индекс по `link_tags(tag_id)` и `link_tags(link_id)` для быстрых join.
- Уникальный индекс `tags(user_id, lower(name))`.

### 3.2 Row Level Security (RLS)

- RLS включена для всех таблиц пользователя.
- Политика `links`: пользователь может `SELECT/INSERT/UPDATE/DELETE` только записи с `user_id = auth.uid()`.
- Политика `tags` аналогично.
- Таблицы импорта/ошибок также ограничены пользователем.
- Админ-права реализуются через роль/claim Supabase: если пользователь имеет `role = 'admin'`, предоставляется доступ к агрегированным данным (например, через `SECURITY DEFINER` view).

### 3.3 Функции и триггеры

- `handle_new_user()` — триггер на `auth.users` для заполнения `profiles`.
- `fetch_link_metadata(url)` — серверная функция (может выполняться через Edge Function) для получения title + favicon и сохранения в Storage.
- `upsert_tags(user_id, tag_names[])` — SQL-функция для массового создания тегов при импорте.
- `record_link_event()` — триггер на `links` для записи в `audit_link_events`.

### 3.4 Supabase Storage

- Bucket `favicons` с публичным доступом на чтение, запись только авторизованным пользователям.
- Имя файла — `userId/hash(url).png`, чтобы избегать коллизий.
- Кэширование изображений через HTTP headers (Cache-Control 1 неделя).

## 4. Потоки данных и пользовательские сценарии

### 4.1 Добавление новой ссылки

1. Пользователь нажимает "Добавить ссылку" → открывается `LinkForm`.
2. При вводе URL выполняется вызов `/api/metadata?url=...`:
   - Route проверяет формат URL (Zod schema).
   - Использует серверную функцию для получения title и favicon.
   - Сохраняет favicon в Supabase Storage, возвращает путь.
3. Форма заполняет поля (title editable), пользователь при необходимости добавляет новые теги.
4. После подтверждения отправляется мутация `useCreateLink` → Supabase `links.insert` + `link_tags`.
5. React Query инвалидация кэша → таблица обновляется.

### 4.2 Inline-редактирование

- Каждая ячейка (кроме favicon) становится редактируемой по клику.
- При подтверждении отправляется PATCH-запрос на Supabase через `update`.
- Для тегов используется multi-select компонент; изменения синхронизируются через `link_tags`.

### 4.3 Удаление

- Кнопка "Удалить" в Actions показывает модальное подтверждение.
- После подтверждения вызывается `useDeleteLink` → удаление записи и каскадное удаление из `link_tags`.

### 4.4 Фильтрация по тегам

- Выбранные теги передаются в запрос на Supabase: `select * from links where user_id = $1 and exists (...)`.
- SQL пример:
  ```sql
  select l.*
  from links l
  join link_tags lt on lt.link_id = l.id
  join tags t on t.id = lt.tag_id
  where l.user_id = $1
  group by l.id
  having array_agg(t.name order by t.name) @> $2::text[];
  ```
- Альтернатива — использовать `INTERSECT` или подзапрос с `count(distinct tag_id)` = количеству выбранных тегов.

### 4.5 Поиск

- Параметры запроса: `search`, `tags`, `sort`, `order`, `page`, `perPage`, `dateFrom`, `dateTo`.
- Реализация через `rpc('search_links', {...})`, чтобы инкапсулировать логику в SQL.
- Поиск включает `title`, `url`, `comment`, `tags.name` (через join и `string_agg`).
- Результат содержит total count и массив ссылок для отображения.

### 4.6 Импорт CSV

1. Пользователь открывает страницу `/import`, загружает CSV.
2. Файл отправляется в `/api/import/preview`.
3. API route:
   - Парсит CSV (например, `papaparse` на клиенте → JSON на сервер).
   - Показывает пользователю предпросмотр, предлагает сопоставить колонки (URL, Title, Comment, Tags, Date).
   - Выполняет валидацию (обязательные поля, корректность URL, формат тегов).
   - Проверяет дубли (уже существующие URL) через Supabase.
4. После подтверждения вызывает `/api/import/commit`:
   - Создает запись в `imports` со статусом `pending`.
   - Батчами отправляет данные в Supabase (до 500 записей за транзакцию).
   - Для новых тегов вызывает `upsert_tags`.
   - Дубли и ошибки записывает в `import_errors`.
   - По завершении обновляет статус `completed` и статистику.
5. UI отображает итоги (сколько импортировано, сколько пропущено и почему).

### 4.7 Экспорт CSV

- На странице `/export` пользователь выбирает: текущий фильтр, все данные или вручную отмеченные записи.
- API `/api/export` формирует CSV:
  - Выполняет запрос к Supabase с заданными фильтрами.
  - Генерирует CSV (строки: URL, Title, Comment, Tags, Date).
  - Отправляет файл с заголовком `Content-Disposition: attachment`.

### 4.8 Админ-панель

- Доступ по маршруту `/admin` только для пользователей с ролью `admin` (claim в JWT Supabase).
- Страница запрашивает агрегированные данные через `rpc` функции или `materialized views`:
  - `select count(*) from profiles`.
  - `select user_id, count(*) as links_count from links group by user_id`.
  - `activity_by_day` view (`date_trunc('day', created_at)`).
  - `popular_tags` view (`tag usage count`).
- В UI используются графики (например, Recharts/Chart.js) и таблицы.

## 5. Интеграции и внешние сервисы

### 5.1 Получение метаданных ссылок

- Используется серверная функция или API route, чтобы не раскрывать ключи внешних сервисов на клиенте.
- Возможные источники:
  - `ogp-parser` (node-пакет) для OpenGraph title/description/icon.
  - Fallback: HTTP-запрос к странице, парсинг `<title>` и `<link rel="icon">`.
- Кеширование метаданных в `links.metadata_source` для повторного использования.
- Если favicon отсутствует, использовать генератор (например, https://www.google.com/s2/favicons) с кэшированием результатов.

### 5.2 Аналитика

- Встраивание счетчиков Яндекс.Метрики и Google Analytics через компонент Layout.
- События: добавление ссылки, импорт, экспорт, переключение темы.

### 5.3 Email

- Supabase Auth использует собственные email-шаблоны (magic link, reset password).
- Дополнительные email (например, отчеты) не требуются на текущем этапе.

## 6. Нефункциональные требования

### 6.1 Производительность

- Основная страница должна загружаться < 2 секунд.
- Поиск < 500 мс при 5000+ ссылках:
  - Использование полнотекстового поиска и индексов.
  - Пагинация на сервере (limit/offset или keyset).
  - Кэширование запросов в React Query.
- Lazy-loading фавиконок (сначала отображать placeholder).

### 6.2 Безопасность

- Использование HTTPS (Vercel и Supabase обеспечивают).
- RLS + JWT для разграничения доступа.
- CSP-заголовки (разрешить только необходимые домены).
- Rate limiting на API маршрутах (например, middleware с ограничением по IP/пользователю).
- Валидация входных данных (Zod на клиенте, Supabase constraints на сервере).
- Защита от XSS: экранирование пользовательских комментариев, использование безопасных рендеринговых методов.

### 6.3 Надежность и бэкапы

- Supabase предоставляет автоматические бэкапы PostgreSQL; дополнительно настроить ежедневные экспортные дампы в отдельное хранилище.
- Пользовательский экспорт CSV служит дополнительным ручным бэкапом.
- Логи ошибок на фронтенде (Sentry) и мониторинг API (Vercel Analytics) — опционально.

### 6.4 Масштабируемость

- Разделение потоков чтения/записи: все операции идут через Supabase, который масштабируется.
- Возможность вынести тяжелые задачи (импорт больших файлов) в background: использовать Supabase Edge Functions + сервис очередей (например, `pgboss`) при необходимости.
- Фавиконки хранятся в CDN Supabase Storage для снижения нагрузки.

## 7. Развертывание и окружения

### 7.1 Окружения

- **Local**: разработчики запускают Next.js (`pnpm dev`/`npm run dev`) + Supabase через локальный CLI (`supabase start`).
- **Staging** (опционально): отдельный проект в Supabase и ветка в Vercel.
- **Production**: основной Supabase проект и прод деплой на Vercel.

### 7.2 CI/CD

- GitHub Actions:
  - Линтинг (`eslint`, `tsc --noEmit`, `prettier --check`).
  - Тесты (unit + e2e при наличии).
  - Деплой на Vercel после успешного прохождения.
- Миграции базы: управляются через Supabase CLI (`supabase migration new`, `supabase db push`).

### 7.3 Настройка Supabase

- Создание проекта, включение Auth (Email + Google).
- Настройка таблиц через миграции.
- Создание bucket `favicons`.
- Настройка RLS-политик.
- Создание сервисного ключа для серверных операций (хранится как `SUPABASE_SERVICE_ROLE_KEY`).
- Подробная инструкция по шагам: [`docs/supabase-setup.md`](./supabase-setup.md).

### 7.4 Переменные окружения (Vercel)

- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`
- `METADATA_FETCHER_SECRET` (если внешний сервис)
- `YANDEX_METRIKA_ID`, `GA_TRACKING_ID`

## 8. Тестирование и качество

### 8.1 Уровни тестов

- **Unit**: компоненты UI (с Jest + React Testing Library), утилиты (парсинг тегов, форматирование дат).
- **Integration**: тесты API routes (Next.js + supertest), проверка взаимодействия с Supabase (mock или тестовая БД).
- **E2E**: Playwright или Cypress — сценарии добавления/редактирования/поиска/импорта.
- **Accessibility**: axe-core для проверки WCAG 2.1 AA.

### 8.2 Контроль качества

- Pre-commit hooks (lint-staged): `eslint`, `prettier`, `tsc --noEmit`.
- Code review: обязательное одобрение перед merge.
- Мониторинг Lighthouse показателей после релиза.

## 9. Дорожная карта реализации

### Этап 1. Инициализация и инфраструктура

#### 1-1. Скелет проекта

Разверните Next.js 14 с App Router, TypeScript, Tailwind, Shadcn/ui, React Query и Zod, чтобы соблюсти требуемую структуру приложения. Пользуйтесь рекомендациями по организации каталогов из [раздела 2.1](#21-структура-проекта-nextjs) и описанием ключевых UI-блоков в [разделе 2.2](#22-ui-компоненты); подготовьте dev-инфраструктуру в соответствии с [разделом 7.1](#71-окружения).

#### 1-2. Интеграция Supabase и миграции

Настройте Supabase CLI и клиент в приложении, добавьте миграции для таблиц `profiles`, `links`, `tags`, `link_tags`, `imports`, `import_errors` и аудита событий. Опираться следует на схему данных из [раздела 3.1](#31-структура-базы-данных), политики доступа из [раздела 3.2](#32-row-level-security-rls), функции и триггеры из [раздела 3.3](#33-функции-и-триггеры), а также на пошаговую настройку проекта из [раздела 7.3](#73-настройка-supabase).

#### 1-3. Аутентификация

Реализуйте регистрацию, вход и выход через Supabase Auth (email + Google), обеспечив guard-компоненты и серверные действия для защищенных маршрутов. Детали по модели профиля приведены в [разделе 3.1](#31-структура-базы-данных), переменные окружения описаны в [разделе 7.4](#74-переменные-окружения-vercel), а UX-требования зафиксированы в [брифе](./brief.md#регистрация-и-авторизация-пользователей).

#### 1-4. Базовый UI-каркас

Соберите общий layout: header с глобальным поиском-заглушкой, переключатель темы, responsive контейнеры и состояние загрузки. Пользуйтесь описанием компонентов в [разделе 2.2](#22-ui-компоненты) и требованиями по адаптивности из [раздела 2.5](#25-адаптивность-и-доступность); визуальные ожидания указаны в [брифе](./brief.md#структура-интерфейса) и разделе [«Профиль пользователя и настройки»](./brief.md#профиль-пользователя-и-настройки).

### Этап 2. Базовый функционал ссылок (MVP 1.0)

#### 2-1. Доменная модель и RLS

Завершите описание схемы данных, индексов и политик доступа для CRUD-операций над ссылками и тегами. Используйте спецификацию из [раздела 3.1](#31-структура-базы-данных), RLS-подход из [раздела 3.2](#32-row-level-security-rls) и требования к фильтрации по тегам из [раздела 4.4](#44-фильтрация-по-тегам).

#### 2-2. API и слой данных

Реализуйте React Query hooks, server components и API routes для чтения списка ссылок с учетом фильтров, сортировок и пагинации. Описанные принципы работы с данными см. в [разделе 2.3](#23-управление-состоянием-и-данные) и потоках [4.1](#41-добавление-новой-ссылки), [4.4](#44-фильтрация-по-тегам) и [4.5](#45-поиск).

#### 2-3. Управление ссылками

Создайте формы и мутации для добавления, редактирования и удаления ссылок с автоподстановкой метаданных и работой с тегами. Технические шаги описаны в [разделах 4.1](#41-добавление-новой-ссылки) и [4.2](#42-inline-редактирование), а UX-требования сформулированы в [брифе](./brief.md#добавление-и-редактирование-ссылок).

#### 2-4. Таблица/список ссылок

Постройте основной компонент таблицы с действиями, отображением тегов и адаптивными режимами. Обратитесь к описанию UI-блоков в [разделе 2.2](#22-ui-компоненты), сценарию inline-редактирования в [разделе 4.2](#42-inline-редактирование) и требованиям из [брифа](./brief.md#основная-таблица) и раздела [«Пагинация»](./brief.md#пагинация).

#### 2-5. Система тегов и фильтров

Реализуйте TagBar, множественный выбор с логикой AND, управление тегами в строке и кнопку «Сбросить все». Подробности доступны в [разделах 2.2](#22-ui-компоненты) и [4.4](#44-фильтрация-по-тегам), а продуктовые ожидания изложены в [брифе](./brief.md#система-тегов) и блоке [«Профиль пользователя и настройки»](./brief.md#профиль-пользователя-и-настройки).

#### 2-6. Поиск, сортировки и адаптивность

Настройте полнотекстовый поиск, сортировки и responsive-поведение таблицы/карточек. Следуйте рекомендациям из [разделов 2.4](#24-поиск-и-фильтрация-на-клиенте), [2.5](#25-адаптивность-и-доступность) и [4.5](#45-поиск); требования по UX зафиксированы в [брифе](./brief.md#поиск), [разделе «Сортировка и фильтры»](./brief.md#сортировка-и-фильтры) и блоке [«Адаптивность»](./brief.md#адаптивность).

### Этап 3. Управление данными и импорт/экспорт

#### 3-1. Сервис метаданных и фавиконок

Создайте маршрут `/api/metadata` для получения title и favicon с кэшированием в Supabase Storage и JSON-полях. Используйте рекомендации из [раздела 5.1](#51-получение-метаданных-ссылок) и описание `LinkForm` в [разделе 2.2](#22-ui-компоненты); запрос на фавиконки отражен в [брифе](./brief.md#планируется-реализовать).

#### 3-2. Импорт CSV

Реализуйте загрузку, предпросмотр, сопоставление полей и дедупликацию при импорте CSV с фиксацией статистики и ошибок. Подробный поток приведен в [разделе 4.6](#46-импорт-csv), работу с тегами автоматизируйте через функции из [раздела 3.3](#33-функции-и-триггеры); продуктовые требования перечислены в [брифе](./brief.md#импорт).

#### 3-3. Экспорт CSV

Добавьте возможность выгружать текущую выборку, все данные или выбранные записи в CSV. Ориентируйтесь на описание в [разделе 4.7](#47-экспорт-csv) и UX-ожидания из [брифа](./brief.md#экспорт).

#### 3-4. Управление тегами и настройками профиля

Расширьте настройки профиля: редактирование тегов и их цветов, выбор темы, обновление персональных данных. Логика хранения и API описаны в [разделах 2.3](#23-управление-состоянием-и-данные) и [3.1](#31-структура-базы-данных), а UX-требования — в [брифе](./brief.md#профиль-пользователя-и-настройки) и разделе [«Система тегов»](./brief.md#система-тегов).

### Этап 4. Администрирование и аналитика

#### 4-1. Админ-панель статистики

Реализуйте страницу `/admin` с агрегированными метриками, графиками активности и популярными тегами, доступную только роли `admin`. Используйте описание представлений из [раздела 4.8](#48-админ-панель) и подходы к SQL-вьюхам в [разделе 3.1](#31-структура-базы-данных); продуктовые сценарии перечислены в [брифе](./brief.md#функционал-админки-простой).

#### 4-2. Интеграция аналитики

Подключите Яндекс.Метрику и Google Analytics, настроив события для ключевых действий и работу с переменными окружения. См. рекомендации из [раздела 5.2](#52-аналитика) и список env-переменных в [разделе 7.4](#74-переменные-окружения-vercel); требования к интеграциям перечислены в [брифе](./brief.md#интеграции).

#### 4-3. Мониторинг производительности и ошибок

Настройте логирование, мониторинг производительности и оповещение об ошибках с целевыми метриками отклика. Ожидания по производительности и надежности описаны в [разделах 6.1](#61-производительность) и [6.3](#63-надежность-и-бэкапы); целевые показатели см. в [брифе](./brief.md#производительность) и [разделе «Надежность»](./brief.md#надежность).

### Этап 5. Релиз, эксплуатация и инструкции

#### 5-1. Финализация тестового контура

Дополните unit, integration и e2e тесты, обеспечьте отчеты по покрытию и автоматический запуск в CI. Стратегии тестирования описаны в [разделе 8.1](#81-уровни-тестов), а критерии качества — в [разделе 8.2](#82-контроль-качества).

#### 5-2. CI/CD и деплой

Настройте GitHub Actions для lint/typecheck/test и деплоя на Vercel, включая применение миграций Supabase. Детали приведены в [разделах 7.2](#72-cicd) и [7.3](#73-настройка-supabase), а переменные окружения перечислены в [разделе 7.4](#74-переменные-окружения-vercel).

#### 5-3. Полный runbook запуска сервиса

Подготовьте пошаговую инструкцию по развертыванию: настройка Supabase с нуля, локальный запуск, деплой на Vercel и проверка работы. Ориентируйтесь на описание окружений в [разделе 7.1](#71-окружения), этапы настройки из [раздела 7.3](#73-настройка-supabase) и требования к документации в [брифе](./brief.md#требования-к-инструкциям).

Дополнительные улучшения (bulk delete, расширенные интеграции и т.п.) собраны в [разделе 10](#10-будущие-расширения).

## 10. Будущие расширения

- **PWA**: добавить сервис-воркер, offline cache (workbox), поддержка установки.
- **Массовые операции**: bulk delete и другие пакетные сценарии управления ссылками.
- **Совместный доступ**: модели `shared_collections`, `team_members` с правами доступа.
- **API для интеграций**: создание REST/GraphQL слоя поверх Supabase.
- **Расширенная аналитика**: сохранение истории посещений, heatmap тегов.
- **Проверка доступности ссылок**: background job, периодический обход ссылок.

## 11. Принципы разработки

- Кодовая база на TypeScript с строгой типизацией.
- Логика фильтрации и поиска сосредоточена на сервере (SQL функции) для консистентности.
- Повторно используемые UI-компоненты документируются (Storybook — опционально).
- Конвенции именования и структура директорий документируются в README/CONTRIBUTING.

---

Документ должен служить основой для разработки и обсуждения изменений архитектуры. Все изменения архитектурных решений рекомендуется фиксировать в отдельных ADR (Architecture Decision Record) для прозрачности эволюции проекта.
